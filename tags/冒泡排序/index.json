[{"content":"现在已经是2021年三月份了，其实今年回来上班以后，一直也没什么事情，摸个鱼划个水，一天就过去了。这周刚开始做需求，不过三下五除二做完了。没什么鱼可以摸，因此决定来写两句。\n过完年回来后，和之前金网的小伙伴（也有可能是老伙伴）们小聚了一下，一个个都是话痨啊，下午七点，搞到晚上十二点都还不打算走。最终抵不过回家漫长的路程，我和小媳妇先回家了。\n这次聚餐我总是觉得哪里不对，虽然还是能融入大家的聊天话题，能吹天吹地。但是总是有点不对。在回去的路上，我左思右想，就是不对，大家的生活好丰富，可以用多姿多彩来形容。有的说这些年遇到了些什么人，有的说经历了个什么事。而我就仅仅是公司接触到的几个人，做的几个需求，如是而已。他们就像一面镜子，把我单调的生活完全的反射在我的眼里，看的明明白白。\n三年多的时间，说长也不长，说短也不短。似乎我除了每天领着工资做着需求，陪着媳妇。并没有其他的不一样。总要说点不一样的，那就是我的社交在一点点的变窄。这是一件很恐怖的事情，忽然让我想起之前在我耳旁飘过的一句话。\n 都工作那么多年了，还靠投简历找工作。\n 以前这个话响起的时候一直我看别人，而现在，需要看自己。自己有多少人脉，有多少朋友。差不多一只手就能数清楚了。\n一个人最怕的应该是就自己没有意识到，说的通俗易懂一点，应该叫自知之明吧，但是感觉又不太像。至少我开始知道，有什么东西，从我身上正在一点点的消失。\n","description":"","id":2,"section":"posts","tags":["Other"],"title":"正在一点点消失的什么","uri":"https://sppan24.github.io/posts/other/%E6%AD%A3%E5%9C%A8%E4%B8%80%E7%82%B9%E7%82%B9%E6%B6%88%E5%A4%B1%E7%9A%84%E4%BB%80%E4%B9%88/"},{"content":"CentOS升级openssl版本 openssl是开放源码的，需要自己去下载源码来进行编译安装。以1.0.2k版本为例。\n一、下载源码 可以从官网下载到本地，然后上传到服务器，也可以去官网找到下载地址，然后使用命令直接下载到服务器。\n最新版：https://www.openssl.org/source/\n历史版本：https://www.openssl.org/source/old/\n例如：\n1  cd ~ \u0026amp;\u0026amp; wget https://www.openssl.org/source/old/1.0.2/openssl-1.0.2k.tar.gz   二、编译源码并安装  下载得到tar.gz的压缩包后，需要先进行解压。  tar -xzvf openssl-1.0.2k.tar.gz 编译配置  切换工作目录到openssl源码的目录：\n1  cd ~/openssl-1.0.2k   执行编译初始化配置，这个地方一定要注意，一定需要加上enable-shared， 不然编译完成以后，不会有.so文件。\n1  ./config enable-shared   参数说明：\n --prefix：表示指定安装目录，如果不指定，默认在/usr/local/ssl -fPIC：编译openssl的静态库 enable-shared：编译动态库  编译并安装  1  make \u0026amp;\u0026amp; make install   三、替换原来低版本的openssl  为了方便出错了进行恢复，需要先将历史版本的程序进行备份。  1 2 3 4  mv /usr/bin/openssl /usr/bin/openssl.bak mv /usr/include/openssl /usr/include/openssl.bak mv /usr/lib64/libssl.so /usr/lib64/libssl.so.bak mv /usr/lib64/libcrypto.so /usr/lib64/libcrypto.so.bak   建立软链到新安装的文件  1 2 3 4  ln -s /usr/local/ssl/bin/openssl /usr/bin/openssl ln -s /usr/local/ssl/include/openssl /usr/include/openssl ln -s /usr/local/ssl/lib/libssl.so.1.0.0 /usr/lib64/libssl.so ln -s /usr/local/ssl/lib/libcrypto.so.1.0.0 /usr/lib64/libcrypto.so   查看安装后的版本信息  1  openssl version -a   ","description":"","id":3,"section":"posts","tags":["Linux"],"title":"CentOS升级openssl版本","uri":"https://sppan24.github.io/posts/linux/centos%E5%8D%87%E7%BA%A7openssl%E7%89%88%E6%9C%AC/"},{"content":" 最近在做CSV文件导出的时候，在Windows下面使用Excel打开总是会出现乱码的情况，需要先将文件转存成GB2312格式才能正常打开，于是在网上找了一番，发现BOM头信息这个东西，加上以后，秒秒秒钟就正常了，所以抽时间整理了一下BOM头信息相关的资料。\n 1、BOM头信息是什么？ BOM的全称为Byte Order Mark，中文名译作”字节顺序标记“。\n在UTF-8编码文件中BOM在文件头部，占用三个字节，用来标识该文件属于UTF-8编码，现在已经有很多软件识别BOM头，但还是有些不能识别BOM头。Windows 就是使用 BOM 来标记文本文件的编码方式的。\n2、常用的BOM头信息    编码 表示 (十六进制) 表示 (十进制)     UTF-8 EF BB BF 239 187 191   GB-18030 84 31 95 33 132 49 149 51    3、生成BOM信息 在文件开始的位置，直接将编码对应的BOM信息以二进制写入到文件中即可。以Java为例：\n1 2  byte[] uft8bom = {(byte) 0XEF, (byte) 0XBB, (byte) 0XBF}; IOUtils.write(uft8bom, fileWriter);   4、扩展 类似WINDOWS自带的记事本等软件，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。但对于 PHP来说，BOM是个大麻烦。PHP并不会忽略BOM，所以在读取、包含或者引用这些文件时，会把BOM作为该文件开头正文的一部分。\n","description":"","id":4,"section":"posts","tags":null,"title":"文件BOM头信息","uri":"https://sppan24.github.io/posts/technology/%E6%96%87%E4%BB%B6bom%E5%A4%B4%E4%BF%A1%E6%81%AF/"},{"content":"路虽远，行则将至。事虽难，做则必成。我们只管向前走，也许走着走着花就开了。也许在未来的某天，回首曾经的中年，我们会感慨道：\u0026ldquo;看，那曾经可爱的，手忙脚乱，一地鸡毛的中年。\u0026rdquo;\n","description":"","id":5,"section":"posts","tags":["Other"],"title":"一地鸡毛的中年","uri":"https://sppan24.github.io/posts/other/%E4%B8%80%E5%9C%B0%E9%B8%A1%E6%AF%9B%E7%9A%84%E4%B8%AD%E5%B9%B4/"},{"content":"在使用Solr做全文检索的过程中，难免需要清空原有的数据再进行索引的重建，下面介绍了四种清空Solr中指定Core数据的方法。\n方式一 基于Solr提供的WEB管理页面进行操作。\n1. 访问WEB管理页面 访问地址为http://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;，例如：\nhttp://10.143.49.137:19807 2. 选择需要操作的core。 这一步可以和第一步直接进行合并，直接使用http://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/#/\u0026lt;core\u0026gt;的方式进行访问即可。\nhttp://10.143.49.137:19807/#/check/ 3.选择Documents选项。 这一步可以和第一步以及第二步直接进行合并，直接使用http://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/#/\u0026lt;core\u0026gt;/documents的方式进行访问即可。\n在文档操作选项表单中按照如下填写。\n Request-Handler (qt)填写/update。 Document Type选择XML。 Document(s)中输入\u0026lt;delete\u0026gt;\u0026lt;query\u0026gt;*:*\u0026lt;/query\u0026gt;\u0026lt;/delete\u0026gt;\u0026lt;commit/\u0026gt;。  填写完毕以后，直接点击Submit Document即可对数据进行清空操作。执行成功则出现如下提示：\nStatus: success Response: { \u0026quot;responseHeader\u0026quot;: { \u0026quot;status\u0026quot;: 0, \u0026quot;QTime\u0026quot;: 8 } } 方式二 使用Solr自带的 post.jar工具，在 apache-solr-XXX/example/exampledocs目录下。\n执行如下命令即可\njava -Ddata=args -jar post.jar \u0026quot;\u0026lt;delete\u0026gt;\u0026lt;query\u0026gt;字段:条件\u0026lt;/query\u0026gt;\u0026lt;/delete\u0026gt;\u0026quot; 工具的其他使用参照java -jar post.jar -help 命令。\n方式三 使用 stream 相关参数请求删除数据\n请求格式为：http://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/\u0026lt;core\u0026gt;/update/?stream.body=xxx的形式。\n例如：\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/\u0026lt;core\u0026gt;/update/?stream.body=\u0026lt;delete\u0026gt;\u0026lt;query\u0026gt;字段:条件\u0026lt;/query\u0026gt;\u0026lt;/delete\u0026gt;\u0026amp;stream.contentType=text/xml;charset=utf-8\u0026amp;commit=true 执行成功则返回如下xml内容：\n1 2 3 4 5 6  \u0026lt;response\u0026gt; \u0026lt;lst name=\u0026#34;responseHeader\u0026#34;\u0026gt; \u0026lt;int name=\u0026#34;status\u0026#34;\u0026gt;0\u0026lt;/int\u0026gt; \u0026lt;int name=\u0026#34;QTime\u0026#34;\u0026gt;6\u0026lt;/int\u0026gt; \u0026lt;/lst\u0026gt; \u0026lt;/response\u0026gt;   方式四 使用CURL的方式发送操作删除。# 删除完后进行提交操作 curl -X POST -H 'content-type:text/xml;charset=utf-8' --data-binary \u0026quot;\u0026lt;delete\u0026gt;\u0026lt;query\u0026gt;字段:条件\u0026lt;/query\u0026gt;\u0026lt;/delete\u0026gt;\u0026lt;commit/\u0026gt;\u0026quot; http://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/\u0026lt;core\u0026gt;/update 说明 在上面的四种操作方法中。\u0026lt;query\u0026gt;字段:条件\u0026lt;/query\u0026gt;均为按照查询条件进行删除，也可以直接换成根据ID删除，格式为\u0026lt;id\u0026gt;条件\u0026lt;/id\u0026gt;。\n","description":"","id":6,"section":"posts","tags":["Solr"],"title":"Solr清空CORE的数据","uri":"https://sppan24.github.io/posts/solr/solr%E6%B8%85%E7%A9%BAcore%E7%9A%84%E6%95%B0%E6%8D%AE/"},{"content":"一、客户端生成公私钥 使用命令在本地客户端生成公私钥（中间的选项直接一路回车默认即可）。\nssh-keygen 命令默认会在~/.ssh目录下生成如下两个文件。\n id_rsa （私钥） id_rsa.pub (公钥)  二、上传公钥到服务器 这里测试用的服务器：地址：192.168.31.100 用户：root。\n使用ssh-copy-id命令将公钥写入到免密登录的服务器上。\nssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.31.100  ssh-copy-id命令可以把本地的ssh公钥文件安装到远程主机对应的账户下的authorized_keys文件中。\n使用模式：\nssh-copy-id [-i [identity_file]] [user@]machine\n 三、测试免密登录 客户端通过ssh连接远程服务器，如果不需要输入密码就可以直接登录，则表示配置成功了。\nssh root@192.168.31.100 ","description":"","id":7,"section":"posts","tags":["Linux"],"title":"Linux免密登录配置","uri":"https://sppan24.github.io/posts/linux/linux%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE/"},{"content":"Idea可以说是Java界的开发利器了。如果安装完成后，能对其进行一定的配置，使用起来一定更加得心应手。但是如果喜欢折腾的朋友，经常进行重装系统，每次都需要重新设置也是个麻烦的事情，所以本文专门介绍了Idea的个性化设置并且将配置文件默认路径转移。即使重装系统，只需要将之前配置好的压缩包解压到目录下即可增城使用。\n一、下载软件 访问官方下载地址：http://www.jetbrains.com/idea/download/other.html，找到自己需要下载的版本，此处为了方便定制，建议下载ZIP Archive with Bundled JBR的版本。\n下载完成后解压文件，得到软件完整目录。后续操作的步骤都以解压后的目录为根目录进行说明和操作。\n二、定制配置文件保存位置 IDEA默认的配置文件保存位置都是根据系统的${user.dir}目录来确定的，一旦重装系统之后，所有的配置信息都丢失了。为了不进行重复性的配置工作，可以将配置文件目录定制到其他位置。\n1、创建保存配置信息的目录 mkdir .IntelliJIdea 2、指定配置信息保存的目录 此步骤需要修改bin/idea.properties文件。在文件的最前面加入如下内容。\nidea.config.path=../.IntelliJIdea/config idea.system.path=../.IntelliJIdea/system idea.plugins.path=${idea.config.path}/plugins idea.log.path=${idea.system.path}/log 三、设置激活信息 1、设置三方插件仓库 Plugins | Custom Plugins Repositories\nhttps://plugins.zhile.io 2、安装试用插件 在插件市场查找插件IDE Eval Reset并安装。\n三、修改System Settings配置 主要进行系统关键设置。\n1、关闭每次自己上次打开的项目 File | Settings | Appearance \u0026amp; Behavior | System Settings。\n将Reopen last project on startup的复选勾选取消。\n2、关闭自动更新 File | Settings | Appearance \u0026amp; Behavior | System Settings | Updates。\n将Automatically check updates for的复选勾选取消。\n四、修改Editor配置 主要是进行编辑器相关设置。\n1、设置字体字号 File | Settings | Editor | Font。\n字体大小设置成14，失败字体设置成幼圆。\n2、设置CodeStyle File | Settings | Editor | Code Style | Java | Code Generation | Comment Code\n取消 Line comment at first start 单行注释从行首开始\n勾选 Add a space at comment start 注释前面自动加空格\n3、设置文件编码方式 File | Settings | Editor | File Encodings。\n将编码全部修改成UTF-8。\n勾选Transparent native-to-ascill conversion复选框。\n4、设置新建文件头信息。 File | Settings | Editor | File and Code Templates。\n找到Include-\u0026gt;File Header，然后填写如下信息。\n/** * Created by SPPan on ${DATE}. */ 4、设置快捷模版 File | Settings | Editor | Live Templates。\nglogger\nprivate static final Logger logger = Logger.getLogger($className$.class); # 变量 className-\u0026gt;className() gcomment\n/** * Author: SPPan * Date: $date$ * Description: $END$ */ # 变量 date-\u0026gt;date(\u0026quot;yyyy/MM/dd\u0026quot;) 五、安装插件 安装完成后，需要先重启软件。\n Free Mybatis plugin GenerateAllSetter Grep Console JRebel and XRebel for IntelliJ Maven Helper CamelCase Rainbow Brackets File Expander CodeGlance  六、构建工具配置 1、Maven配置修改 File | Settings | Build, Execution, Deployment | Build Tools | Maven。\n 将maven成自己安装的版本。 将maven配置文件指定为自己安装的版本的配置文件。 勾选Always update snapshots复选框。  2、开启项目自动编译 File | Settings | Build, Execution, Deployment | Compiler。\n 勾选Build project automatically复选框 在打开项目视图后，双击Shift，输入Registry,然后找到compiler.automake.allow.when.app.runing复选框并勾选。  ","description":"","id":8,"section":"posts","tags":["Soft","Idea"],"title":"定制自己的IDEA开发工具","uri":"https://sppan24.github.io/posts/soft/%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84idea%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":9,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://sppan24.github.io/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":10,"section":"gallery","tags":null,"title":"Photo","uri":"https://sppan24.github.io/gallery/photo/"},{"content":"基数排序算法很特殊，它不需要直接对元素进行相互比较，也不需要将元素相互交换，你需要做的就是对元素进行“分类”。\n将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n一、排序步骤  取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）；  二、动画演示 三、代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  package com.whoismy8023.learning.sort; import java.util.Arrays; /** * Created by SPPan on 2019/9/11. * \u0026lt;p\u0026gt; * 基数排序 */ public class RadixSortLearning { public static void main(String[] args) { int[] arr = {1, 9, 2, 8, 3, 6, 5, 4}; System.out.printf(\u0026#34;排序前:%s \\n\u0026#34;, Arrays.toString(arr)); radixSort(arr); System.out.printf(\u0026#34;排序后:%s \\n\u0026#34;, Arrays.toString(arr)); } private static void radixSort(int[] arr) { // 得到数组中最大的数的位数，假设第一数就是最大数  int max = arr[0]; for (int i = 1; i \u0026lt; arr.length; i++) { if (arr[i] \u0026gt; max) { max = arr[i]; } } // 得到最大数是几位数  int maxLength = String.valueOf(max).length(); // 定义一个二维数组，表示 10 个桶, 每个桶就是一个一维数组  // 说明  // 1. 二维数组包含 10 个一维数组  // 2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为 arr.length  // 3. 名明确，基数排序是使用空间换时间的经典算法  int[][] bucket = new int[10][arr.length]; // 为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数  // 可以这里理解  // 比如：bucketElementCounts[0] , 记录的就是 bucket[0] 桶的放入数据个数  int[] bucketElementCounts = new int[10]; for (int i = 0, n = 1; i \u0026lt; maxLength; i++, n *= 10) { // (针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..  for (int j = 0; j \u0026lt; arr.length; j++) { // 取出每个元素的对应位的值  int digitOfElement = arr[j] / n % 10; // 放入到对应的桶中  bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; } // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)  int index = 0; // 遍历每一桶，并将桶中是数据，放入到原数组  for (int k = 0; k \u0026lt; bucketElementCounts.length; k++) { // 如果桶中，有数据，我们才放入到原数组  if (bucketElementCounts[k] != 0) { // 循环该桶即第 k 个桶(即第 k 个一维数组), 放入  for (int l = 0; l \u0026lt; bucketElementCounts[k]; l++) { // 取出元素放入到 arr  arr[index++] = bucket[k][l]; } } // 第 i+1 轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！  bucketElementCounts[k] = 0; } } } }   四、代码演示结果 1 2  排序前:[1, 9, 2, 8, 3, 6, 5, 4] 排序后:[1, 2, 3, 4, 5, 6, 8, 9]   ","description":"","id":15,"section":"posts","tags":["排序算法","基数排序"],"title":"排序算法之基数排序","uri":"https://sppan24.github.io/posts/algorithm/sort/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"content":"归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。\n作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：\n 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代；  一、排序步骤  申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。  二、动画演示 三、代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  package com.whoismy8023.learning.sort; import java.util.Arrays; /** * Created by SPPan on 2019/9/11. * \u0026lt;p\u0026gt; * 归并排序 */ public class MergeSortLearning { public static void main(String[] args) { int[] arr = {1, -1, 2, -2, 3, 6, 5, 4}; System.out.printf(\u0026#34;排序前:%s \\n\u0026#34;, Arrays.toString(arr)); mergeSort(arr, 0, arr.length - 1, new int[arr.length]); System.out.printf(\u0026#34;排序后:%s \\n\u0026#34;, Arrays.toString(arr)); } private static void mergeSort(int[] arr, int left, int right, int[] temp) { if (left \u0026gt;= right) { return; } // 中间索引  int mid = (left + right) / 2; // 向左递归进行分解  mergeSort(arr, left, mid, temp); // 向右递归进行分解  mergeSort(arr, mid + 1, right, temp); // 合并  merge(arr, left, mid, right, temp); } private static void merge(int[] arr, int left, int mid, int right, int[] temp) { // 初始化左边序列的指针  int l = left; // 初始化右边序列的指针  int r = mid + 1; // 将数据复制到辅助数组  for (int i = left; i \u0026lt;= right; i++) { temp[i] = arr[i]; } for (int i = left; i \u0026lt;= right; i++) { if (l \u0026gt; mid) { // 此处表示左边序列已经处理完成，将右边序列剩余的复制回来即可  arr[i] = temp[r++]; } else if (r \u0026gt; right) { // 此处表示右边序列已经处理完成，将左边序列剩余的复制回来即可  arr[i] = temp[l++]; } else if (temp[l] \u0026lt; temp[r]) { // 此处表示两边序列都还没处理完，且左边的数据小于右边  arr[i] = temp[l++]; } else { // 此处表示两边序列都还没处理完，且右边的数据小于右边  arr[i] = temp[r++]; } } System.out.printf(\u0026#34;合并%d到%d后的结果：%s \\n\u0026#34;, left, right, Arrays.toString(arr)); } }   四、代码演示结果 1 2 3 4 5 6 7 8 9  排序前:[1, -1, 2, -2, 3, 6, 5, 4] 合并0到1后的结果：[-1, 1, 2, -2, 3, 6, 5, 4] 合并2到3后的结果：[-1, 1, -2, 2, 3, 6, 5, 4] 合并0到3后的结果：[-2, -1, 1, 2, 3, 6, 5, 4] 合并4到5后的结果：[-2, -1, 1, 2, 3, 6, 5, 4] 合并6到7后的结果：[-2, -1, 1, 2, 3, 6, 4, 5] 合并4到7后的结果：[-2, -1, 1, 2, 3, 4, 5, 6] 合并0到7后的结果：[-2, -1, 1, 2, 3, 4, 5, 6] 排序后:[-2, -1, 1, 2, 3, 4, 5, 6]   ","description":"","id":16,"section":"posts","tags":["排序算法","归并排序"],"title":"排序算法之归并排序","uri":"https://sppan24.github.io/posts/algorithm/sort/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"content":"堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：\n 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；  一、排序步骤  构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)； 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换；  二、动画演示 三、代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  package com.whoismy8023.learning.sort; import java.util.Arrays; /** * Created by SPPan on 2019/9/9. */ public class HeapSortLearning { public static void main(String[] args) { int[] arr = {1, 9, 2, 8, 3, 6, 5, 4}; System.out.printf(\u0026#34;排序前:%s \\n\u0026#34;, Arrays.toString(arr)); heapSort(arr); System.out.printf(\u0026#34;排序后:%s \\n\u0026#34;, Arrays.toString(arr)); } //堆排序  private static void heapSort(int[] arr) { // 堆创建,第一个元素是最大的  buildMaxHeap(arr); for (int i = arr.length - 1; i \u0026gt; 0; i--) { // 将堆顶元素和堆底元素进行交换  int temp = arr[0]; arr[0] = arr[i]; arr[i] = temp; adjustDownToTop(arr, 0, i); } } // 创建大根堆  private static int[] buildMaxHeap(int[] arr) { // 从最后一个父结点开始  for (int i = arr.length / 2 - 1; i \u0026gt;= 0; i--) { adjustDownToTop(arr, i, arr.length); } return arr; } private static void adjustDownToTop(int[] arr, int k, int length) { // 提取该父结点的值存入temp中  int temp = arr[k]; // 初始化k结点的左孩子结点为i  for (int i = 2 * k + 1; i \u0026lt;= length - 1; i = 2 * i + 1) { // 选取值最大的子结点的下标(注意该结点可能没有右子结点，所以判断条件为i+1\u0026lt;length.不能等于)  if (i + 1 \u0026lt; length \u0026amp;\u0026amp; arr[i] \u0026lt; arr[i + 1]) { // 如果右结点值大于左结点  i++; } // 如果比父结点大，和父结点交换位置  if (arr[i] \u0026lt;= temp) { break; } else { arr[k] = arr[i]; //用于最后的赋值  k = i; } } arr[k] = temp; } }   四、代码演示结果 1 2  排序前:[1, 9, 2, 8, 3, 6, 5, 4] 排序后:[1, 2, 3, 4, 5, 6, 8, 9]   ","description":"","id":17,"section":"posts","tags":["排序算法","堆排序"],"title":"排序算法之堆排序","uri":"https://sppan24.github.io/posts/algorithm/sort/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"content":"快速排序（Quicksort）是对冒泡排序的一种改进。\n通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n一、排序步骤  从数列中挑出一个元素，称为 \u0026ldquo;基准\u0026rdquo;（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；  二、动画演示 三、代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  package com.whoismy8023.learning.sort; import java.util.Arrays; /** * Created by SPPan on 2019/9/8. * \u0026lt;p\u0026gt; * 快速排序 */ public class QuickSortLearning { public static void main(String[] args) { int[] arr = {-1, -2, 0, 1, 9, 6, 4, 2, 3}; System.out.printf(\u0026#34;排序前:%s \\n\u0026#34;, Arrays.toString(arr)); quickSort(arr, 0, arr.length - 1); System.out.printf(\u0026#34;排序后:%s \\n\u0026#34;, Arrays.toString(arr)); } private static void quickSort(int[] arr, int left, int right) { if (left \u0026gt;= right) { return; } int p = partition(arr, left, right); // 对左边的子数组进行快速排序  quickSort(arr, left, p - 1); // 对右边的子数组进行快速排序  quickSort(arr, p + 1, right); } private static int partition(int[] arr, int left, int right) { // 默认使用最左边边作为基准值，放在到最右边  swap(arr, left, right); int i, curIndex; for (i = left, curIndex = left; curIndex \u0026lt; right; curIndex++) { if (arr[curIndex] \u0026lt;= arr[right]) { swap(arr, i++, curIndex); } } swap(arr, i, curIndex); return i; } private static void swap(int[] arr, int left, int right) { int tmp = arr[left]; arr[left] = arr[right]; arr[right] = tmp; } }   四、代码演示结果 1 2  排序前:[-1, -2, 0, 1, 9, 6, 4, 2, 3] 排序后:[-2, -1, 0, 1, 2, 3, 4, 6, 9]   ","description":"","id":18,"section":"posts","tags":["排序算法","快速排序"],"title":"排序算法之快速排序","uri":"https://sppan24.github.io/posts/algorithm/sort/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"content":"是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。\n希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；\n随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。\n一、排序思路  选择一个增量序列 t1，t2，……，tk，其中 ti \u0026gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度；  二、动画演示 三、代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  package com.whoismy8023.learning.sort; import java.util.Arrays; /** * Created by SPPan on 2019/9/6. * \u0026lt;p\u0026gt; * 希尔排序 */ public class ShellSortLearning { public static void main(String[] args) { int[] arr = {1, 9, 2, 8, 3, 6, 5, 4}; System.out.printf(\u0026#34;排序前:%s \\n\u0026#34;, Arrays.toString(arr)); shellSort(arr); System.out.printf(\u0026#34;排序后:%s \\n\u0026#34;, Arrays.toString(arr)); } private static void shellSort(int[] arr) { int run = 1; for (int gap = arr.length / 2; gap \u0026gt; 0; gap = gap / 2) { for (int i = gap; i \u0026lt; arr.length; i++) { int insertIndex = i; int insertVal = arr[i]; if (arr[insertIndex] \u0026lt; arr[insertIndex - gap]) { while (insertIndex - gap \u0026gt;= 0 \u0026amp;\u0026amp; insertVal \u0026lt; arr[insertIndex - gap]) { arr[insertIndex] = arr[insertIndex - gap]; insertIndex = insertIndex - gap; } arr[insertIndex] = insertVal; } } System.out.printf(\u0026#34;第%d轮后的结果：%s \\n\u0026#34;, run++, Arrays.toString(arr)); } } }   四、代码演示结果 1 2 3 4 5  排序前:[1, 9, 2, 8, 3, 6, 5, 4] 第1轮后的结果：[1, 6, 2, 4, 3, 9, 5, 8] 第2轮后的结果：[1, 4, 2, 6, 3, 8, 5, 9] 第3轮后的结果：[1, 2, 3, 4, 5, 6, 8, 9] 排序后:[1, 2, 3, 4, 5, 6, 8, 9]   ","description":"","id":19,"section":"posts","tags":["排序算法","希尔排序"],"title":"排序算法之希尔排序","uri":"https://sppan24.github.io/posts/algorithm/sort/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"},{"content":"对欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。\n把n个待排序的元素看成为一个有序表和一个无序表。\n开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。\n一、排序步骤  从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。  二、动画演示 三、代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  package com.whoismy8023.learning.sort; import java.util.Arrays; /** * Created by SPPan on 2019/9/6. * \u0026lt;p\u0026gt; * 直接插入排序 */ public class InsertSortLearning { public static void main(String[] args) { int[] arr = {1, -1, 2, -2, 3, 6, 5, 4}; System.out.printf(\u0026#34;排序前:%s \\n\u0026#34;, Arrays.toString(arr)); insertSort(arr); System.out.printf(\u0026#34;排序后:%s \\n\u0026#34;, Arrays.toString(arr)); } private static void insertSort(int[] arr) { int insertIndex; int currVal; for (int i = 1; i \u0026lt; arr.length; i++) { currVal = arr[i]; insertIndex = i - 1; while (insertIndex \u0026gt;= 0 \u0026amp;\u0026amp; currVal \u0026lt; arr[insertIndex]) { arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; } if (insertIndex + 1 != i) { arr[insertIndex + 1] = currVal; } System.out.printf(\u0026#34;第%d轮后的结果：%s \\n\u0026#34;, i, Arrays.toString(arr)); } } }   四、代码演示结果 1 2 3 4 5 6 7 8 9  排序前:[1, -1, 2, -2, 3, 6, 5, 4] 第1轮后的结果：[-1, 1, 2, -2, 3, 6, 5, 4] 第2轮后的结果：[-1, 1, 2, -2, 3, 6, 5, 4] 第3轮后的结果：[-2, -1, 1, 2, 3, 6, 5, 4] 第4轮后的结果：[-2, -1, 1, 2, 3, 6, 5, 4] 第5轮后的结果：[-2, -1, 1, 2, 3, 6, 5, 4] 第6轮后的结果：[-2, -1, 1, 2, 3, 5, 6, 4] 第7轮后的结果：[-2, -1, 1, 2, 3, 4, 5, 6] 排序后:[-2, -1, 1, 2, 3, 4, 5, 6]   ","description":"","id":20,"section":"posts","tags":["排序算法","插入排序"],"title":"排序算法之插入排序","uri":"https://sppan24.github.io/posts/algorithm/sort/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"content":"从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。\n一、排序步骤  第一次从 arr[0]~arr[n-1]中选取最小值，与 arr[0]交换； 第二次从 arr[1]~arr[n-1]中选取最小值，与 arr[1]交换； 第三次从 arr[2]~arr[n-1]中选取最小值，与 arr[2]交换； … 第 i 次从 arr[i-1]~arr[n-1]中选取最小值，与 arr[i-1]交换； … 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值，与 arr[n-2]交换；  总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。\n二、动画演示 三、代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  package com.whoismy8023.learning.sort; import java.util.Arrays; /** * Created by SPPan on 2019/9/3. * \u0026lt;p\u0026gt; * 选择排序 */ public class SelectSortLearning { public static void main(String[] args) { int[] arr = {-1, -2, 0, 1, 9, 6, 4, 2, 3}; System.out.printf(\u0026#34;排序前:%s \\n\u0026#34;, Arrays.toString(arr)); selectSort(arr); System.out.printf(\u0026#34;排序后:%s \\n\u0026#34;, Arrays.toString(arr)); } private static void selectSort(int[] arr) { for (int i = 0; i \u0026lt; arr.length; i++) { // 每次获取本轮中的第一个数作为最小值哨兵  int minIndex = i; int min = arr[i]; // 从本轮的第下一个值开始逐一比较  for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[j] \u0026lt; min) { minIndex = j; min = arr[j]; } } // 只有出现哨兵指向的不是本轮的第一个的时候，才发生交换。  if (minIndex != i) { arr[minIndex] = arr[i]; arr[i] = min; } System.out.printf(\u0026#34;第%d轮后的结果：%s\\n\u0026#34;, i + 1, Arrays.toString(arr)); } } }   四、代码演示结果 1 2 3 4 5 6 7 8 9 10 11  排序前:[-1, -2, 0, 1, 9, 6, 4, 2, 3] 第1轮后的结果：[-2, -1, 0, 1, 9, 6, 4, 2, 3] 第2轮后的结果：[-2, -1, 0, 1, 9, 6, 4, 2, 3] 第3轮后的结果：[-2, -1, 0, 1, 9, 6, 4, 2, 3] 第4轮后的结果：[-2, -1, 0, 1, 9, 6, 4, 2, 3] 第5轮后的结果：[-2, -1, 0, 1, 2, 6, 4, 9, 3] 第6轮后的结果：[-2, -1, 0, 1, 2, 3, 4, 9, 6] 第7轮后的结果：[-2, -1, 0, 1, 2, 3, 4, 9, 6] 第8轮后的结果：[-2, -1, 0, 1, 2, 3, 4, 6, 9] 第9轮后的结果：[-2, -1, 0, 1, 2, 3, 4, 6, 9] 排序后:[-2, -1, 0, 1, 2, 3, 4, 6, 9]   ","description":"","id":21,"section":"posts","tags":["排序算法","选择排序"],"title":"排序算法之选择排序","uri":"https://sppan24.github.io/posts/algorithm/sort/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"content":"通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。\n冒泡排序的思想就是利用的比较交换，利用循环将第i小或者大的元素进行归位，归位操作利用的是对n个元素中相邻的两个元素进行比较，如果顺序正确就不交换，如果顺序错误就进行位置的交换。\n因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。\n一、排序步骤  比较相邻的元素。如果第一个比第二个大（小），就交换他们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大（小）的数； 针对所有的元素重复以上的步骤，除了最后已经选出的元素（有序）； 每次对越来越少的元素（无序元素）重复上面的步骤，直到没有任何一对数字需要比较，则序列最终有序；  二、动画演示 三、代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  package com.whoismy8023.learning.sort; import java.util.Arrays; /** * Created by SPPan on 2019/9/2. * \u0026lt;p\u0026gt; * 冒泡排序实现 */ public class BubbleSortLearning { public static void main(String[] args) { int[] arr = {1, -1, 2, -2, 3, 6, 5, 4}; System.out.printf(\u0026#34;排序前:%s \\n\u0026#34;, Arrays.toString(arr)); bubbleSort(arr); System.out.printf(\u0026#34;排序后:%s \\n\u0026#34;, Arrays.toString(arr)); } private static void bubbleSort(int[] arr) { for (int i = 0; i \u0026lt; arr.length - 1; i++) { boolean hasSwap = false; for (int j = 0; j \u0026lt; arr.length - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { hasSwap = true; arr[j] = arr[j] ^ arr[j + 1]; arr[j + 1] = arr[j] ^ arr[j + 1]; arr[j] = arr[j] ^ arr[j + 1]; } } if (!hasSwap) { break; } System.out.printf(\u0026#34;第%d轮后的结果:%s \\n\u0026#34;, i + 1, Arrays.toString(arr)); } } }   四、代码演示结果 1 2 3 4 5  排序前:[1, -1, 2, -2, 3, 6, 5, 4] 第1轮后的结果:[-1, 1, -2, 2, 3, 5, 4, 6] 第2轮后的结果:[-1, -2, 1, 2, 3, 4, 5, 6] 第3轮后的结果:[-2, -1, 1, 2, 3, 4, 5, 6] 排序后:[-2, -1, 1, 2, 3, 4, 5, 6]   ","description":"","id":22,"section":"posts","tags":["排序算法","冒泡排序"],"title":"排序算法之冒泡排序","uri":"https://sppan24.github.io/posts/algorithm/sort/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"content":"SPPanLogs专门用来记录工作和生活中遇到的一些问题和感悟。\n 程序员 程序员 程序员  ","description":"关于页面","id":23,"section":"","tags":null,"title":"关于","uri":"https://sppan24.github.io/about/"},{"content":"1、介绍 排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。\n2、分类 2.1、内部排序 指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。\n2.2、外部排序 数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。\n3、效率度量 3.1、时间复杂度 3.1.1、计算方式  忽略常数项 忽略低次项 忽略系数  3.1.2、常见时间复杂度  常数阶 O(1) 对数阶 O(log2n) 线性阶 O(n) 线性对数阶 O(nlog2n) 平方阶 O(n^2) 立方阶 O(n^3) k 次方阶 O(n^k) 指数阶 O(2^n)  3.2、空间复杂度 4、常用排序算法 4.1、冒泡排序 排序算法之冒泡排序\n4.2、快速排序 排序算法之快速排序\n4.3、选择排序 排序算法之选择排序\n4.4、堆排序 排序算法之堆排序\n4.5、插入排序 排序算法之插入排序\n4.6、希尔排序 排序算法之希尔排序\n4.7、归并排序 排序算法之归并排序\n4.8、基数排序 排序算法之基数排序\n","description":"","id":24,"section":"posts","tags":["排序算法"],"title":"排序算法概述","uri":"https://sppan24.github.io/posts/algorithm/sort/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"}]